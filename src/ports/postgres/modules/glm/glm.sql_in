/* ----------------------------------------------------------------------- *//**
 *
 * @file glm.sql_in
 *
 * @brief SQL functions for GLM (Poisson)
 * @date June 2014
 *
 * @sa For a brief introduction to GLM (Poisson), see the
 *     module description \ref grp_poisson.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_poisson

<div class="toc"><b>Contents</b><ul>
<li class="level1"><a href="#train">Training Function</a></li>
<li class="level1"><a href="#predict">Prediction Function</a></li>
<li class="level1"><a href="#examples">Examples</a></li>
<li class="level1"><a href="#background">Technical Background</a></li>
<li class="level1"><a href="#literature">Literature</a></li>
<li class="level1"><a href="#related">Related Topics</a></li>
</ul></div>

@brief Model count data and contingency tables.
Poisson regression assumes the dependent variable has a Poisson distribution,
and assumes the logarithm of its expected value can be modeled by a linear combination of unknown parameters.

Poisson regression is used to model count data and contingency tables. It assumes the dependent variable has a Poisson distribution,
and the logarithm of its expected value is a linear combination of unknown parameters. Poisson regression models are generalized linear models with the logarithm as the (canonical) link function,
and the Poisson distribution function as the probability distribution.

@anchor train
@par Training Function
GLM training function has the following format:
<pre class="syntax">
glm(source_table,
    model_table,
    dependent_varname,
    independent_varname,
    family_params,
    grouping_col,
    optim_params,
    verbose
    )
</pre>
\b Arguments
<DL class="arglist">
  <DT>source_table</DT>
  <DD>TEXT. The name of the table containing the training data.</DD>

  <DT>model_table</DT>
  <DD>TEXT. Name of the generated table containing the model.

    The model table produced by glm contains the following columns:

    <table class="output">
      <tr>
        <th>&lt;...&gt;</th>
        <td>Text. Grouping columns, if provided in input. This could be multiple columns
          depending on the \c grouping_col input.</td>
      </tr>

      <tr>
        <th>coef</th>
        <td>FLOAT8. Vector of the coefficients in linear predictor.</td>
      </tr>

      <tr>
        <th>log_likelihood</th>
        <td>FLOAT8. The log-likelihood \f$ l(\boldsymbol \beta) \f$.</td>
      </tr>

      <tr>
        <th>std_err</th>
        <td>FLOAT8[]. Vector of the standard error of the coefficients.</td>
      </tr>

      <tr>
        <th>z_stats</th>
        <td>FLOAT8[]. Vector of the z-statistics of the coefficients.</td>
      </tr>

      <tr>
        <th>p_values</th>
        <td>FLOAT8[]. Vector of the p-values of the coefficients.</td>
      </tr>

      <tr>
        <th>num_rows_processed</th>
        <td>BIGINT. Numbers of rows processed.</td>
      </tr>

      <tr>
        <th>num_rows_skipped</th>
        <td>BIGINT. Numbers of rows skipped due to missing values or failures.</td>
      </tr>

      <tr>
        <th>num_iterations</th>
        <td>INTEGER. The number of iterations actually completed. This would be different
          from the \c nIterations argument if a \c tolerance parameter is provided and the
          algorithm converges before all iterations are completed.</td>
      </tr>
    </table>

    A summary table named \<model_table\>_summary is also created at the same time, which has the following columns:
     <table class="output">

    <tr>
    <th>method</th>
    <td>'glm'</td>
    </tr>

    <tr>
    <th>source_table</th>
    <td>The data source table name.</td>
    </tr>

    <tr>
    <th>model_table</th>
    <td>The model table name.</td>
    </tr>

    <tr>
    <th>dependent_varname</th>
    <td>The dependent variable.</td>
    </tr>

    <tr>
    <th>independent_varname</th>
    <td>The independent variables</td>
    </tr>

    <tr>
    <th>family_params</th>
    <td>A string that contains family parameters, and has the form of 'family=..., link=...'</td>
    </tr>

    <tr>
    <th>grouping_col</th>
    <td>Name of grouping columns.</td>
    </tr>

    <tr>
    <th>optimizer_params</th>
    <td>A string that contains optimizer parameters, and has the form of 'optimizer=..., max_iter=..., tolerance=...'</td>
    </tr>

    <tr>
    <th>num_all_groups</th>
    <td>Number of groups in glm training.</td>
    </tr>

    <tr>
    <th>num_failed_groups</th>
    <td>Number of failed groups in glm training.</td>
    </tr>

    <tr>
      <th>total_rows_processed</th>
      <td>BIGINT. Total numbers of rows processed in all groups.</td>
    </tr>

    <tr>
      <th>total_rows_skipped</th>
      <td>BIGINT. Total numbers of rows skipped in all groups due to missing values or failures.</td>
    </tr>

   </table>
  </DD>

  <DT>dependent_varname</DT>
  <DD>TEXT. Name of the dependent variable column.</DD>

  <DT>independent_varname</DT>
  <DD>TEXT. Expression list to evaluate for the
    independent variables. An intercept variable is not assumed. It is common to
    provide an explicit intercept term by including a single constant \c 1 term in
    the independent variable list.</DD>

  <DT>family_params (optional)</DT>
  <DD>TEXT, Parameters for distribution family. Currently, we
    support family=poisson and link=[log or identity or sqrt].</DD>

  <DT>grouping_col (optional)</DT>
  <DD>TEXT, default: NULL. An expression list used to group
    the input dataset into discrete groups, running one regression per group.
    Similar to the SQL "GROUP BY" clause. When this value is NULL, no
    grouping is used and a single model is generated.</DD>

  <DT>optim_params (optional)</DT>
  <DD>TEXT, default: 'max_iter=100,optimizer=irls,tolerance=1e-6'.
    Parameters for optimizer. Currently, we support
    tolerance=[tolerance for relative error between log-likelihoods],
    max_iter=[maximum iterations to run], optimizer=irls.</DD>

  <DT>verbose (optional)</DT>
  <DD>BOOLEAN, default: FALSE. Provides verbose output of the results of training.</DD>
</DL>

<dd>@note For p-values, we just return the computation result directly.
Other statistical packages, like 'R', produce the same result, but on printing the
result to screen, another format function is used and any p-value that is
smaller than the machine epsilon (the smallest positive floating-point number
'x' such that '1 + x != 1') will be printed on screen as "< xxx" (xxx is the
value of the machine epsilon). Although the result may look different, they are
in fact the same.
</dd>

@anchor predict
@par Prediction Function
Users can use the inverse of link function over madlib.array_dot to make
predictions. In Poisson regression with log link function,
<code>exp(array_dot(coef, x))</code> is what the prediction call looks like.

@anchor examples
@examp
-# Create the training data table.
<pre class="example">
CREATE TABLE warpbreaks(
    id      serial,
    breaks  integer,
    wool    char(1),
    tension char(1)
);
INSERT INTO warpbreaks(breaks, wool, tension) VALUES
(26, 'A', 'L'),
(30, 'A', 'L'),
(54, 'A', 'L'),
(25, 'A', 'L'),
(70, 'A', 'L'),
(52, 'A', 'L'),
(51, 'A', 'L'),
(26, 'A', 'L'),
(67, 'A', 'L'),
(18, 'A', 'M'),
(21, 'A', 'M'),
(29, 'A', 'M'),
(17, 'A', 'M'),
(12, 'A', 'M'),
(18, 'A', 'M'),
(35, 'A', 'M'),
(30, 'A', 'M'),
(36, 'A', 'M'),
(36, 'A', 'H'),
(21, 'A', 'H'),
(24, 'A', 'H'),
(18, 'A', 'H'),
(10, 'A', 'H'),
(43, 'A', 'H'),
(28, 'A', 'H'),
(15, 'A', 'H'),
(26, 'A', 'H'),
(27, 'B', 'L'),
(14, 'B', 'L'),
(29, 'B', 'L'),
(19, 'B', 'L'),
(29, 'B', 'L'),
(31, 'B', 'L'),
(41, 'B', 'L'),
(20, 'B', 'L'),
(44, 'B', 'L'),
(42, 'B', 'M'),
(26, 'B', 'M'),
(19, 'B', 'M'),
(16, 'B', 'M'),
(39, 'B', 'M'),
(28, 'B', 'M'),
(21, 'B', 'M'),
(39, 'B', 'M'),
(29, 'B', 'M'),
(20, 'B', 'H'),
(21, 'B', 'H'),
(24, 'B', 'H'),
(17, 'B', 'H'),
(13, 'B', 'H'),
(15, 'B', 'H'),
(15, 'B', 'H'),
(16, 'B', 'H'),
(28, 'B', 'H');
SELECT create_dummy_coding('warpbreaks', 'warpbreaks_dummy', 'wool,tension');
</pre>

-# Train a GLM model.
<pre class="example">
SELECT glm('warpbreaks_dummy',
           'glm_model',
           'breaks',
           'ARRAY[1.0,"wool_B","tension_M", "tension_H"]',
           'family=poisson, link=log');
</pre>

-# View the regression results.
<pre class="example">
-- Set extended display on for easier reading of output
\\x on
SELECT * FROM glm_model;
</pre>

Result:
<pre class="result">
coef               | {3.69196314494079,-0.205988442638621,-0.321320431600611,-0.51848849651156}
log_likelihood     | -242.527983208979
std_err            | {0.04541079434248,0.0515712427835191,0.0602659166951256,0.0639595193956924}
z_stats            | {81.3014438174473,-3.99425011926316,-5.3317106786264,-8.10651020224019}
p_values           | {0,6.48993254938271e-05,9.72918600322907e-08,5.20943463005751e-16}
num_rows_processed | 54
num_rows_skipped   | 0
iteration          | 5
</pre>

-# Alternatively, unnest the arrays in the results for easier reading of output:
<pre class="example">
\\x off
SELECT unnest(coef) as coefficient,
       unnest(std_err) as standard_error,
       unnest(z_stats) as z_stat,
       unnest(p_values) as pvalue
FROM glm_model;
</pre>

-# Predicting dependent variable using GLM model.
(This example uses the original data table to perform the prediction. Typically
a different test dataset with the same features as the original training dataset
would be used for prediction.)
In GLM training, we used log as the link function and, thus, exp() as the inverse of it.
<pre class="example">
\\x off
-- Display prediction value along with the original value
SELECT w.id, exp(madlib.array_dot(coef, ARRAY[1, "wool_B", "tension_M", "tension_H"]::float8[])) as mu
FROM warpbreaks_dummy w, glm_model m
ORDER BY w.id;
</pre>

@anchor notes
@par Notes
All table names can be optionally schema qualified (current_schemas() would be
searched if a schema name is not provided) and all table and column names
should follow case-sensitivity and quoting rules per the database.
(For instance, 'mytable' and 'MyTable' both resolve to the same entity, i.e. 'mytable'.
If mixed-case or multi-byte characters are desired for entity names then the
string should be double-quoted; in this case the input would be '"MyTable"').


@anchor related
@par Related Topics

File glm.sql_in documenting the training function

\ref grp_linreg

\ref grp_logreg

\ref grp_mlogreg

\ref grp_robust

\ref grp_clustered_errors

\ref grp_validation

\ref grp_marginal

@internal
@sa Namespace GLM (documenting the driver/outer loop implemented in
    Python), Namespace
    \ref madlib::modules::regress documenting the implementation in C++
@endinternal
*/


------------------------------------------------------------------------

DROP TYPE IF EXISTS MADLIB_SCHEMA.__glm_result_type CASCADE;
CREATE TYPE MADLIB_SCHEMA.__glm_result_type AS (
        coef double precision[],
        loglik double precision,
        std_err double precision[],
        z_stats double precision[],
        p_values double precision[],
        num_rows_processed bigint
);

------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_merge_states(
        state1 MADLIB_SCHEMA.bytea8,
        state2 MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME', 'glm_merge_states'
LANGUAGE C IMMUTABLE STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_final(
        state MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME', 'glm_final'
LANGUAGE C IMMUTABLE STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------
------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_poisson_log_transition(
        MADLIB_SCHEMA.bytea8,
        double precision,
        double precision[],
        MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME', 'glm_poisson_log_transition'
LANGUAGE C IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__glm_poisson_log_agg(
        double precision, double precision[], MADLIB_SCHEMA.bytea8);
CREATE AGGREGATE MADLIB_SCHEMA.__glm_poisson_log_agg(
        /*+ y */                double precision,
        /*+ x */                double precision[],
        /*+ previous_state */   MADLIB_SCHEMA.bytea8) (

    STYPE=MADLIB_SCHEMA.bytea8,
    SFUNC=MADLIB_SCHEMA.__glm_poisson_log_transition,
    m4_ifdef(`__POSTGRESQL__', `', `prefunc=MADLIB_SCHEMA.__glm_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.__glm_final,
    INITCOND=''
);

------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_poisson_identity_transition(
        MADLIB_SCHEMA.bytea8,
        double precision,
        double precision[],
        MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME', 'glm_poisson_identity_transition'
LANGUAGE C IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__glm_poisson_identity_agg(
        double precision, double precision[], MADLIB_SCHEMA.bytea8);
CREATE AGGREGATE MADLIB_SCHEMA.__glm_poisson_identity_agg(
        /*+ y */                double precision,
        /*+ x */                double precision[],
        /*+ previous_state */   MADLIB_SCHEMA.bytea8) (

    STYPE=MADLIB_SCHEMA.bytea8,
    SFUNC=MADLIB_SCHEMA.__glm_poisson_identity_transition,
    m4_ifdef(`__POSTGRESQL__', `', `prefunc=MADLIB_SCHEMA.__glm_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.__glm_final,
    INITCOND=''
);

------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_poisson_sqrt_transition(
        MADLIB_SCHEMA.bytea8,
        double precision,
        double precision[],
        MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME', 'glm_poisson_sqrt_transition'
LANGUAGE C IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.__glm_poisson_sqrt_agg(
        double precision, double precision[], MADLIB_SCHEMA.bytea8);
CREATE AGGREGATE MADLIB_SCHEMA.__glm_poisson_sqrt_agg(
        /*+ y */                double precision,
        /*+ x */                double precision[],
        /*+ previous_state */   MADLIB_SCHEMA.bytea8) (

    STYPE=MADLIB_SCHEMA.bytea8,
    SFUNC=MADLIB_SCHEMA.__glm_poisson_sqrt_transition,
    m4_ifdef(`__POSTGRESQL__', `', `prefunc=MADLIB_SCHEMA.__glm_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.__glm_final,
    INITCOND=''
);

------------------------------------------------------------------------
------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_result(
        /*+ state */ MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.__glm_result_type
AS 'MODULE_PATHNAME', 'glm_result'
LANGUAGE C IMMUTABLE STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__glm_loglik_diff(
        /*+ state1 */ MADLIB_SCHEMA.bytea8,
        /*+ state2 */ MADLIB_SCHEMA.bytea8)
RETURNS double precision
AS 'MODULE_PATHNAME', 'glm_loglik_diff'
LANGUAGE C IMMUTABLE STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

------------------------------------------------------------------------
------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm(
    source_table        varchar,
    model_table         varchar,
    dependent_varname   varchar,
    independent_varname varchar,
    family_params       varchar,
    grouping_col       varchar,
    optim_params        varchar,
    verbose             boolean
) RETURNS void AS $$
PythonFunction(glm, glm, glm)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

-- entry functions with default values
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm(
    source_table        varchar,
    model_table         varchar,
    dependent_varname   varchar,
    independent_varname varchar,
    family_params       varchar,
    grouping_col       varchar,
    optim_params        varchar
) RETURNS void AS $$
    SELECT MADLIB_SCHEMA.glm($1, $2, $3, $4, $5, $6, $7, FALSE);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm(
    source_table        varchar,
    model_table         varchar,
    dependent_varname   varchar,
    independent_varname varchar,
    family_params       varchar,
    grouping_col       varchar
) RETURNS void AS $$
    SELECT MADLIB_SCHEMA.glm($1, $2, $3, $4, $5, $6, NULL, FALSE);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm(
    source_table        varchar,
    model_table         varchar,
    dependent_varname   varchar,
    independent_varname varchar,
    family_params       varchar
) RETURNS void AS $$
    SELECT MADLIB_SCHEMA.glm($1, $2, $3, $4, $5, NULL, NULL, FALSE);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

-- skip the default family before we implement gaussian using this framework


-- Help messages -------------------------------------------------------
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm(
    message    TEXT
) RETURNS TEXT AS $$
    PythonFunction(glm, glm, glm_help_msg)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.glm()
RETURNS TEXT
AS $$
    SELECT MADLIB_SCHEMA.glm(NULL::TEXT);
$$ LANGUAGE SQL IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
