"""@file matrix_ops.py_in

@namespace linalg
"""

import plpy
from utilities.utilities import __mad_version
from utilities.utilities import extract_keyvalue_params
from utilities.utilities import unique_string
from utilities.utilities import _assert
from utilities.validate_args import get_cols
from utilities.validate_args import is_col_array
from utilities.validate_args import table_exists
from utilities.validate_args import table_is_empty
from utilities.validate_args import columns_exist_in_table

version_wrapper = __mad_version()
string_to_array = version_wrapper.select_vecfunc()
array_to_string = version_wrapper.select_vec_return()


def _is_sparse(matrix_in, val):
    return not is_col_array(matrix_in, val)


def _matrix_default_args():
    return {
        'row': 'row_num',
        'col': 'col_num',
        'val': 'val',
        'trans': False
        }


def parse_matrix_args(matrix_args, in_default_args=None):
    """ Parse name-value pair string for a matrix
    Args:
        @param matrix_args: Can be either dict or string.
            If dict, then it's returned as is
            If str, then it's expected to contain key-value pairs
                in format "key=value"
            Supported keys:
                row = Name of the column containing row id
                col = Name of the column containing column id
                val = Name of the column containing values
                trans = Boolean indicating if a matrix should be transposed before operation

    Returns:
         Dictionary: Parses the matrix_args and creates a dictionary containing
         all the {names: value}
    """
    default_args = _matrix_default_args()
    if in_default_args:
        default_args.update(in_default_args)
    if not matrix_args:
        return default_args
    if isinstance(matrix_args, dict):
        return matrix_args
    if not isinstance(matrix_args, str):
        raise ValueError("Matrix error: invalid input for matrix args")
    params_types = {'row': str, 'col': str, 'val': str, 'trans': bool}
    matrix_params = extract_keyvalue_params(matrix_args,
                                            params_types,
                                            default_args)
    return matrix_params


def cast_dense_input_table_to_correct_columns(schema_madlib, matrix_in,
                                              matrix_out, row_id):
    # If the source table is already formatted as needed, do nothing,
    # Otherwise, create a new temp table containing the data in the needed format (if possible).
    # Returns true if a new table was generated.  Returns false otherwise.
    _validate_output_table(matrix_out)
    _validate_input_table(matrix_in)
    cols = get_cols(matrix_in, schema_madlib)
    createTable = False
    if len(cols) == 2:
        cols.remove(row_id)
        if not is_col_array(matrix_in, cols[0]):
            plpy.error("SVD error: Data column should be of type array!")
        if cols[0] != "row_vec" or row_id != "row_id":
            plpy.execute(
                """
                CREATE TEMP TABLE {matrix_out} as
                    SELECT {row_id} as row_id, {vec} as row_vec
                    FROM {matrix_in}
                """.format(matrix_out=matrix_out,
                           row_id=row_id, vec=cols[0], matrix_in=matrix_in))
            createTable = True
    else:
        plpy.execute(
            """
            SELECT {schema_madlib}.__matrix_column_to_array_format (
                '{matrix_in}', '{row_id}', '{matrix_out}', False)
            """.format(schema_madlib=schema_madlib, matrix_in=matrix_in,
                       row_id=row_id,
                       matrix_out=matrix_out))
        createTable = True
    return createTable
# ------------------------------------------------------------------------------


def _validate_output_table(table):
    _assert(table is not None and table.replace('"', '').strip() != '',
            "Matrix error: Invalid output table ({0})".format(table))


def _validate_input_table(table):
    _assert(table is not None and table.replace('"', '').strip() != '',
            "Matrix error: Invalid input table ({0})".format(table))
    _assert(table_exists(table),
            "Matrix error: The input table ({0}) doesn't exist".format(table))


def _validate_sparse(matrix, matrix_args, checkCol=True):
    _assert(table_exists(matrix),
            "Matrix error: Could not find input table " + matrix)
    _assert(not table_is_empty(matrix),
            "Matrix error: The input table ({0}) is empty".format(matrix))
    if checkCol:
        _assert(columns_exist_in_table(matrix,
                                       [matrix_args[i] for i in ('row', 'col', 'val')]),
                "Matrix error: Missing columns from matrix {0}".format(matrix))
        _assert(not is_col_array(matrix, matrix_args['val']),
                "Matrix error: invalid column ({0}) should not be an array "
                "datatype".format(matrix_args['val']))

    # verify that the matrix row_id, col_id elements are unique and not missing
    c = unique_string()
    non_unique_rows = plpy.execute("""
            SELECT {matrix_args[row]} as r, {matrix_args[col]} as c
            FROM {matrix}
            GROUP BY {matrix_args[row]}, {matrix_args[col]}
            HAVING  count(*) > 1
            ORDER BY r, c
           """.format(**locals()))
    if non_unique_rows:
        bad_rows = [str(i['r']) + "  |  " + str(i['c']) for i in non_unique_rows[:100]]
        plpy.error(
            """Matrix error: Following entries are duplicated in sparse matrix ({m}) .

(Displaying a maximum of 100 entries)
{row}  | {col}
-----------------------------------
{all_rows}
            """.format(m=matrix,
                       row=matrix_args['row'],
                       col=matrix_args['col'],
                       all_rows="\n".join(bad_rows)))

    # Sparse representation requires passing the dimension of the input matrix
    # as one of the elements. This element will have a NULL for it's value column.
    # we need to verify that there is only 1 element with a NULL as value
    rv = plpy.execute(" SELECT count(*) cnt FROM {matrix} "
                      " WHERE {val} IS NULL".format(matrix=matrix,
                                                    val=matrix_args['val']))
    _assert(len(rv) == 1, "Matrix error: more than one NULL "
                          "value found in the {0} column".format(matrix_args['val']))


def _validate_dense(matrix, matrix_args, checkCol=True, row_dim=None):
    _assert(table_exists(matrix), "Matrix error: Could not find table {0}".format(matrix))
    if checkCol:
        cols = [matrix_args[i] for i in ('row', 'val')]
        _assert(columns_exist_in_table(
                    matrix, cols),
                "Matrix error: Missing columns (one of {0}) "
                "from matrix {1}".format(','.join(cols), matrix))
        _assert(is_col_array(matrix, matrix_args['val']),
                "Matrix error: invalid column ({0}) should be an array "
                "datatype".format(matrix_args['val']))

    # verify that the matrix row_id, col_id elements are unique and not missing
    if row_dim is None:
        row_dim = plpy.execute("SELECT max({0}) + 1 as max_row_dim FROM {1}".
                               format(matrix_args['row'], matrix))[0]['max_row_dim']
    c = unique_string()
    non_unique_rows = plpy.execute("""
            SELECT {matrix_args[row]} as r
            FROM {matrix}
            GROUP BY {matrix_args[row]}
            HAVING (count(*) > 1)

            UNION

            SELECT {c} as r
            FROM (
                SELECT {matrix_args[row]}, {c}
                FROM {matrix} RIGHT OUTER JOIN
                        generate_series(0, {row_dim} - 1) as {c}
                ON ({matrix_args[row]} = {c})
            ) q
            WHERE {matrix_args[row]} is NULL
            ORDER BY r;
           """.format(**locals()))
    if non_unique_rows:
        bad_rows = [str(i['r']) for i in non_unique_rows[:100]]
        plpy.error(
            """Matrix error: Following {row} values are either missing or duplicated in dense matrix ({m}).

(Displaying a maximum of 100 entries)
{row}
------------
{all_rows}
            """.format(m=matrix,
                       row=matrix_args['row'],
                       all_rows="\n".join(bad_rows)))


def _validate_block(matrix, matrix_args):
    _assert(table_exists(matrix), "The input table {0} doesn't exist".format(matrix))
    _assert(columns_exist_in_table(matrix,
                                   [matrix_args['row'],
                                    matrix_args['col'],
                                    matrix_args['val']]),
            "Matrix error: One or more input columns ({0})"
            " don't exist in the table ({1}) representing a block matrix".
            format(','.join([matrix_args['row'], matrix_args['col'],
                             matrix_args['val']]),
                   matrix))
    _assert(is_col_array(matrix, matrix_args['val']),
            "Matrix error: Invalid block column - array expected")
    _assert(not table_is_empty(matrix),
            "Matrix error: Input table {0} is empty".format(matrix))
# ------------------------------------------------------------------------------


def get_dims(matrix, matrix_args, is_block=False):
    if is_block:
        rv1 = plpy.execute("""
            SELECT
                max({matrix_args[row]}) as max_row_id,
                max({matrix_args[col]}) as max_col_id
            FROM {matrix}
            """.format(matrix=matrix, matrix_args=matrix_args))[0]
        rv2 = plpy.execute("""
            SELECT
                (array_upper({matrix_args[val]}, 1) -
                 array_lower({matrix_args[val]}, 1) + 1) AS block_row_dim,
                (array_upper({matrix_args[val]}, 2) -
                 array_lower({matrix_args[val]}, 2) + 1) AS block_col_dim
            FROM {matrix}
            WHERE {matrix_args[row]} = 0 and {matrix_args[col]} = 0
            """.format(matrix=matrix, matrix_args=matrix_args))[0]
        rv3 = plpy.execute("""
            SELECT
                (array_upper({matrix_args[val]}, 1) -
                 array_lower({matrix_args[val]}, 1) + 1) AS block_row_dim,
                (array_upper({matrix_args[val]}, 2) -
                 array_lower({matrix_args[val]}, 2) + 1) AS block_col_dim
            FROM {matrix}
            WHERE {matrix_args[row]} = {max_row_id} and
                  {matrix_args[col]} = {max_col_id}
            """.format(matrix=matrix, matrix_args=matrix_args,
                       max_row_id=rv1['max_row_id'],
                       max_col_id=rv1['max_col_id']))[0]

        row_dim = rv1['max_row_id'] * rv2['block_row_dim'] + rv3['block_row_dim']
        col_dim = rv1['max_col_id'] * rv2['block_col_dim'] + rv3['block_col_dim']
    elif _is_sparse(matrix, matrix_args['val']):
        rv = plpy.execute("""
            SELECT
                {matrix_args[row]} AS row_dim,
                {matrix_args[col]} AS col_dim
            FROM {matrix}
            WHERE {matrix_args[val]} is NULL
            """.format(matrix=matrix, matrix_args=matrix_args))
        _assert(len(rv) == 1,
                "Matrix error: Missing dimension information in the "
                "input sparse matrix ({0})".format(matrix))
        row_dim = rv[0]['row_dim']
        col_dim = rv[0]['col_dim']
    else:
        rv = plpy.execute("""
            SELECT max({matrix_args[row]}) + 1 AS row_dim
            FROM {matrix}
            """.format(matrix=matrix, matrix_args=matrix_args))
        row_dim = rv[0]['row_dim']
        rv = plpy.execute("""
            SELECT
                (array_upper({matrix_args[val]}, 1) -
                     array_lower({matrix_args[val]}, 1) + 1)
                AS col_dim
            FROM
                {matrix}
            LIMIT 1
            """.format(matrix=matrix, matrix_args=matrix_args))
        col_dim = rv[0]['col_dim']
    return (row_dim, col_dim)


def matrix_sparsify(matrix_in, in_args,
                    matrix_out, out_args, use_temp_table=False):

    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)
    in_args = parse_matrix_args(in_args)
    (row_dim, col_dim) = get_dims(matrix_in, in_args)
    _validate_dense(matrix_in, in_args, row_dim=row_dim)

    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'val': in_args['val']})
    temp = 'TEMP' if use_temp_table else ''

    plpy.execute('DROP TABLE IF EXISTS %s' % matrix_out)
    temp_col_id, temp_val = unique_string(), unique_string()
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {in_args[row]} as {out_args[row]},
            {temp_col_id} as {out_args[col]},
            {temp_val} as {out_args[val]}
        FROM
        (
            SELECT
                {in_args[row]},
                unnest({in_args[val]}) AS {temp_val},
                generate_series(0, {col_dim} - 1) AS {temp_col_id}
            FROM
                {matrix_in}
        ) t1
        WHERE
            {temp_val} <> 0
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))
    plpy.execute("""
        INSERT INTO {matrix_out} VALUES({row_dim}, {col_dim}, NULL)
        """.format(matrix_out=matrix_out, row_dim=row_dim, col_dim=col_dim))


def matrix_densify(schema_madlib, matrix_in, in_args,
                   matrix_out, out_args, use_temp_table=False):

    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)
    in_args = parse_matrix_args(in_args)
    _validate_sparse(matrix_in, in_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'val': in_args['val']})
    temp = '' if not use_temp_table else 'TEMP'

    (row_dim, col_dim) = get_dims(matrix_in, in_args)
    plpy.execute('DROP TABLE IF EXISTS %s' % matrix_out)
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {in_args[row]} AS {out_args[row]},
            {schema_madlib}.__matrix_densify_agg(
                {col_dim}, {in_args[col]}, {in_args[val]}) AS {out_args[val]}
        FROM
            {matrix_in}
        WHERE
            {in_args[val]} IS NOT NULL
        GROUP BY
            {in_args[row]}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))

    # Add vector with all zeros for rows that were not present in the sparse matrix
    plpy.execute("""
        INSERT INTO {matrix_out}
        SELECT row as {out_args[row]}, val as {out_args[val]}
        FROM
        (
            SELECT row
            FROM generate_series(0, {row_dim} - 1) AS row
            WHERE row NOT IN
                    (
                        SELECT {in_args[row]} as row
                        FROM {matrix_in}
                        GROUP BY {in_args[row]}
                    )
        ) t1,
        (
            SELECT array_agg(val * 0) AS val
            FROM generate_series(0, {col_dim} - 1) AS val
        ) t2
        """.format(**locals()))
# ------------------------------------------------------------------------------


def matrix_trans(schema_madlib, matrix_in, in_args,
                 matrix_out, out_args, use_temp_table=False):
    """ Main function for transpose of matrix

    Args:
        @param schema_madlib: Name of the MADlib schema
        @param matrix_in: Str, Name of the matrix to be transposed
        @param in_args: Str, Key-value string providing column names for matrix_in
                        The string is of the format "key1=value1, key2=value2 ..."
                        This is parsed to obtain a dictionary.
                        Alternatively this argument can also be a dictionary
                        containing the key-value information (in which case no
                                                              parsing is performed)
        @param matrix_out: Str, Name of the matrix to contain transposed result
        @param out_args: Str, Key-value string providing column names for
                                matrix_out. Like in_args, this can also be dictionary.
        @param use_temp_table: Bool, If True, output is added to a temp table
    Returns:
        None
    Side effect:
        Creates an output table containing the transpose of matrix_in
    """
    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)
    in_args = parse_matrix_args(in_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'col': in_args['col'],
                                                  'val': in_args['val']})

    if _is_sparse(matrix_in, in_args['val']):
        _validate_sparse(matrix_in, in_args)
        return _matrix_trans_sparse(
            schema_madlib, matrix_in, in_args,
            matrix_out, out_args, use_temp_table)
    else:
        _validate_dense(matrix_in, in_args)
        return _matrix_trans_dense(
            schema_madlib, matrix_in, in_args,
            matrix_out, out_args, use_temp_table)


def _matrix_trans_sparse(schema_madlib, matrix_in, in_args,
                         matrix_out, out_args, use_temp_table):
    temp = 'TEMP' if use_temp_table else ''
    plpy.execute('DROP TABLE IF EXISTS %s' % matrix_out)
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {in_args[row]} AS {out_args[col]},
            {in_args[col]} AS {out_args[row]},
            {in_args[val]} AS {out_args[val]}
        FROM
            {matrix_in}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[col]})')
        """.format(matrix_in=matrix_in,
                   in_args=in_args,
                   matrix_out=matrix_out,
                   out_args=out_args,
                   temp=temp))


def _matrix_trans_dense(schema_madlib, matrix_in, in_args,
                        matrix_out, out_args, use_temp_table=False):
    temp = 'TEMP' if use_temp_table else ''
    (row_dim, col_dim) = get_dims(matrix_in, in_args)
    temp_row, temp_col, temp_val = (unique_string() for i in range(3))
    plpy.execute('DROP TABLE IF EXISTS %s' % matrix_out)
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {temp_col} AS {out_args[row]},
            {schema_madlib}.__matrix_densify_agg(
                {row_dim}, {temp_row}, {temp_val}) AS {out_args[val]}
        FROM
        (   SELECT {in_args[row]} as {temp_row},
                   unnest({in_args[val]}) AS {temp_val},
                   generate_series(0, {col_dim} - 1) AS {temp_col}
            FROM
                {matrix_in}
        ) t1
        GROUP BY
           {temp_col}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))
# ------------------------------------------------------------------------------


def matrix_mult(schema_madlib, matrix_a, a_args,
                matrix_b, b_args, matrix_out, out_args=None,
                use_temp_table=False):

    _validate_input_table(matrix_a)
    _validate_input_table(matrix_b)
    _validate_output_table(matrix_out)

    a_args = parse_matrix_args(a_args)
    b_args = parse_matrix_args(b_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': a_args['row'],
                                                  'col': a_args['col'],
                                                  'val': a_args['val']})

    matrix_out1 = unique_string() + "_a1"
    if a_args['trans']:
        matrix_trans(schema_madlib, matrix_a, a_args, matrix_out1, None)
        matrix_a = matrix_out1

    matrix_out2 = unique_string() + "_a2"
    if b_args['trans']:
        matrix_trans(schema_madlib, matrix_b, b_args, matrix_out2, None)
        matrix_b = matrix_out2

    a_dim = get_dims(matrix_a, a_args)
    b_dim = get_dims(matrix_b, b_args)

    _assert(min(a_dim) > 0 and min(b_dim) > 0,
            "Matrix error: Invalid dimensions for input matrices")
    _assert(a_dim[1] == b_dim[0],
            "Matrix error: Dimension mismatch for matrix multiplication.\n"
            "Left matrix, col dimension = {0}, "
            "Right matrix, row dimension = {1}".format(a_dim[1], b_dim[0]))

    # both matrix_a and matrix_b are dense
    if (not _is_sparse(matrix_a, a_args['val']) and
            not _is_sparse(matrix_b, b_args['val'])):
        _validate_dense(matrix_a, a_args, row_dim=a_dim[0])
        _validate_dense(matrix_b, b_args, row_dim=b_dim[0])
        _matrix_mult_dense(schema_madlib, matrix_a, a_args,
                           matrix_b, b_args, matrix_out, out_args,
                           use_temp_table=use_temp_table)
        plpy.execute("DROP TABLE IF EXISTS {0}".format(matrix_out1))
        plpy.execute("DROP TABLE IF EXISTS {0}".format(matrix_out2))
        return

    # sparsify matrix_a if not sparse
    matrix_out3 = unique_string() + "_a3"
    if not _is_sparse(matrix_a, a_args['val']):
        matrix_sparsify(matrix_a, a_args,
                        matrix_out3, _matrix_default_args())
        matrix_a = matrix_out3
        a_args = _matrix_default_args()
    _validate_sparse(matrix_a, a_args)

    # sparsify matrix_b if not sparse
    matrix_out4 = unique_string() + "_a4"
    if not _is_sparse(matrix_b, b_args['val']):
        matrix_sparsify(matrix_b, b_args, matrix_out4, _matrix_default_args())
        matrix_b = matrix_out4
        b_args = _matrix_default_args()
    _validate_sparse(matrix_b, b_args)

    matrix_out5 = unique_string() + "_a5"
    _matrix_mult_sparse(schema_madlib, matrix_a, a_args,
                        matrix_b, b_args,
                        matrix_out5, _matrix_default_args(),
                        use_temp_table=use_temp_table)

    matrix_densify(schema_madlib,
                   matrix_out5, _matrix_default_args(),
                   matrix_out, out_args)

    for table in ("matrix_out%d" % (i) for i in range(1, 6)):
        plpy.execute("DROP TABLE IF EXISTS {0}".format(table))


def _matrix_mult_sparse(schema_madlib, matrix_a, a_args,
                        matrix_b, b_args, matrix_out, out_args,
                        use_temp_table=False):

    a_dim = get_dims(matrix_a, a_args)
    b_dim = get_dims(matrix_b, b_args)
    temp_row, temp_col, temp_val = (unique_string() for i in range(3))
    temp = "TEMP" if use_temp_table else ''
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {temp_row} as {out_args[row]},
            {temp_col} as {out_args[col]},
            sum({temp_val}) AS {out_args[val]}
        FROM
        (
            SELECT
                a.{a_args[row]} AS {temp_row},
                b.{b_args[col]} AS {temp_col},
                a.{a_args[val]}::float8 * b.{b_args[val]}::float8 AS {temp_val}
            FROM
                {matrix_a} AS a,
                {matrix_b} AS b
            WHERE
                a.{a_args[val]} IS NOT NULL AND
                b.{b_args[val]} IS NOT NULL AND
                a.{a_args[col]} = b.{b_args[row]}
        ) t
        GROUP BY
            {temp_row}, {temp_col}
        m4_ifdef(`__POSTGRESQL__', `', `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))
    plpy.execute("""
        INSERT INTO {matrix_out} VALUES ({row_count}, {col_count}, NULL)
        """.format(matrix_out=matrix_out,
                   row_count=a_dim[0],
                   col_count=b_dim[1]))


def _matrix_mult_dense(schema_madlib, matrix_a, a_args,
                       matrix_b, b_args, matrix_out, out_args,
                       use_temp_table=False):

    temp_row, temp_col, temp_val = (unique_string() for i in range(3))
    a_dim = get_dims(matrix_a, a_args)
    b_dim = get_dims(matrix_b, b_args)
    temp = "TEMP" if use_temp_table else ''
    # compute trans of matrix_b to compute dot product between
    # rows of matrix_a and cols of matrix_b
    matrix_b_trans = unique_string() + "_a6"
    b_trans_args = _matrix_default_args()
    _matrix_trans_dense(schema_madlib,
                        matrix_b, b_args,
                        matrix_b_trans, b_trans_args,
                        use_temp_table=False)
    # compute dot products and store in sparse format
    matrix_r_sparse = unique_string() + "_a7"
    r_s_args = _matrix_default_args()
    plpy.execute("""
        CREATE TEMP TABLE {matrix_r_sparse}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            a.{a_args[row]} AS {r_s_args[row]},
            b.{b_trans_args[row]} AS {r_s_args[col]},
            {schema_madlib}.array_dot(
                a.{a_args[val]}::float8[],
                b.{b_trans_args[val]}::float8[]) AS {r_s_args[val]}
        FROM
            {matrix_a} AS a, {matrix_b_trans} AS b
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({r_s_args[row]})')
        """.format(**locals()))
    # densify result
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {r_s_args[row]} as {out_args[row]},
            {schema_madlib}.__matrix_densify_agg(
                {col_dim}, {r_s_args[col]}, {r_s_args[val]}) AS {out_args[val]}
        FROM
            {matrix_r_sparse}
        GROUP BY
            {r_s_args[row]}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(col_dim=b_dim[1], **locals()))
    plpy.execute("DROP TABLE IF EXISTS " + matrix_r_sparse)
    plpy.execute("DROP TABLE IF EXISTS " + matrix_b_trans)
# ------------------------------------------------------------------------------


def matrix_square(schema_madlib, matrix_in, in_args,
                  matrix_out, out_args):
    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)

    in_args = parse_matrix_args(in_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'col': in_args['col'],
                                                  'val': in_args['val']})

    dim = get_dims(matrix_in, in_args)
    _assert(dim[1] == dim[0],
            "Matrix error: Square operation is only defined for square matrices")
    if _is_sparse(matrix_in, in_args['val']):
        _validate_sparse(matrix_in, in_args)
        _matrix_mult_sparse(schema_madlib, matrix_in, in_args,
                            matrix_in, in_args,
                            matrix_out, out_args)
    else:
        _validate_dense(matrix_in, in_args, row_dim=dim[0])
        _matrix_mult_dense(schema_madlib, matrix_in, in_args,
                           matrix_in, in_args, matrix_out, out_args)
# ------------------------------------------------------------------------------


def matrix_norm(schema_madlib, matrix_in, in_args, norm_type, **kwargs):
    """
    Perform a matrix norm operation on a dense matrix
    Args:
        @param schema_madlib    Name of the schema where MADlib is installed
        @param matrix_a         Name of the source table
        @param norm_type        Name of the output table

    Returns:
        @param norm

    Throws:
        plpy.error if any argument is invalid

    """

    _validate_input_table(matrix_in)
    if norm_type is None:
        norm_type = 'fro'

    # Add any supported norm types here for easy error checking
    SUPPORTED_NORM_TYPES = ['fro']
    if norm_type not in SUPPORTED_NORM_TYPES:
        plpy.error("Matrix Norm Error: Supported norm types are (%s)",
                   ','.join(SUPPORTED_NORM_TYPES))
    in_args = parse_matrix_args(in_args)

    norm = plpy.execute(
        """
        SELECT sqrt(sum(s)) as p
        FROM (
            SELECT
                {schema_madlib}.array_dot({in_args[val]}, {in_args[val]}) as s
            FROM
                {source_table}
        ) Q1
        """.format(source_table=matrix_in,
                   schema_madlib=schema_madlib,
                   in_args=in_args))

    # Return the norm
    return norm[0]['p']
# ------------------------------------------------------------------------------


def matrix_scale_and_add(schema_madlib,
                         matrix_a,
                         a_args,
                         matrix_b,
                         b_args,
                         scale,
                         matrix_out,
                         out_args,
                         **kwargs):
    """
    Perform a matrix scale operation on a dense matrix, e.g, A + c*B.
    Args:
        @param schema_madlib    Name of the schema where MADlib is installed
        @param matrix_a         Matrix input A
        @param matrix_b         Matrix input B
        @param scale            Scale in the scale and add operation
        @param matrix_out         Matrix R

    Returns:
        @param norm

    Throws:
        plpy.error if any argument is invalid

    """
    # TODO: this function only works with dense matrices. Need to add sparse support
    _validate_input_table(matrix_a)
    _validate_input_table(matrix_b)
    _validate_output_table(matrix_out)

    a_args = parse_matrix_args(a_args)
    b_args = parse_matrix_args(b_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': a_args['row'],
                                                  'col': a_args['col'],
                                                  'val': a_args['val']})
    a_dim = get_dims(matrix_a, a_args)
    b_dim = get_dims(matrix_b, b_args)
    _assert(min(a_dim) > 0 and min(b_dim) > 0,
            "Matrix error: Invalid dimensions for input matrices")
    _assert(a_dim[0] == b_dim[0] and a_dim[1] == b_dim[1],
            "Matrix error: The dimensions of the two matrices don't match")

    _validate_dense(matrix_a, a_args, row_dim=a_dim[0])
    _validate_dense(matrix_b, b_args, row_dim=b_dim[0])

    if scale is None:
        plpy.error("Matrix error : Scale cannot be NULL")

    # Create a dense matrix table
    plpy.execute(
        """
        CREATE TABLE {matrix_out} AS
            SELECT a.{a_args[row]} as {out_args[row]},
                   {schema_madlib}.array_add(a.{a_args[val]},
                        {schema_madlib}.array_scalar_mult(b.{b_args[val]},
                                                   ({scale})::DOUBLE PRECISION))
                        as {out_args[val]}
            FROM
                {matrix_a} as a, {matrix_b} as b
            WHERE a.{a_args[row]} = b.{b_args[row]}
        """.format(**locals()))
# ------------------------------------------------------------------------------


def matrix_add(schema_madlib, matrix_a, a_args,
               matrix_b, b_args, matrix_out, out_args,
               use_temp_table=False):
    _validate_input_table(matrix_a)
    _validate_input_table(matrix_b)
    _validate_output_table(matrix_out)

    a_args = parse_matrix_args(a_args)
    b_args = parse_matrix_args(b_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': a_args['row'],
                                                  'col': a_args['col'],
                                                  'val': a_args['val']})

    a_dim = get_dims(matrix_a, a_args)
    b_dim = get_dims(matrix_b, b_args)
    _assert(min(a_dim) > 0 and min(b_dim) > 0,
            "Matrix error: Invalid dimensions for input matrices")
    _assert(a_dim[0] == b_dim[0] and a_dim[1] == b_dim[1],
            "Matrix error: The dimensions of the two matrices don't match")

    if _is_sparse(matrix_a, a_args['val']) and _is_sparse(matrix_b, b_args['val']):
        # both matrix_a and matrix_b are sparse
        _validate_sparse(matrix_a, a_args)
        _validate_sparse(matrix_b, b_args)
        _matrix_add_sparse(schema_madlib, matrix_a, a_args,
                           matrix_b, b_args, matrix_out, out_args,
                           False)
        return

    # densify matrix_a if sparse
    matrix_out1 = unique_string() + "_a1"
    if _is_sparse(matrix_a, a_args['val']):
        matrix_densify(schema_madlib, matrix_a, a_args,
                       matrix_out1, _matrix_default_args(), False)
        matrix_a = matrix_out1
        a_args = _matrix_default_args()
    _validate_dense(matrix_a, a_args, a_dim[0])

    # densify matrix_b if sparse
    matrix_out2 = unique_string() + "_a2"
    if _is_sparse(matrix_b, b_args['val']):
        matrix_densify(schema_madlib, matrix_b, b_args,
                       matrix_out2, _matrix_default_args(), False)
        matrix_b = matrix_out2
        b_args = _matrix_default_args()
    _validate_dense(matrix_b, b_args, b_dim[0])

    _matrix_add_dense(schema_madlib, matrix_a, a_args,
                      matrix_b, b_args, matrix_out, out_args,
                      False)

    plpy.execute("DROP TABLE IF EXISTS " + matrix_out1)
    plpy.execute("DROP TABLE IF EXISTS " + matrix_out2)


def _matrix_add_sparse(schema_madlib, matrix_a, a_args,
                       matrix_b, b_args, matrix_out, out_args,
                       use_temp_table=False):
    temp = '' if not use_temp_table else 'TEMP'
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            coalesce(a.{a_args[row]}, b.{b_args[row]}) AS {out_args[row]},
            coalesce(a.{a_args[col]}, b.{b_args[col]}) AS {out_args[col]},
            coalesce(a.{a_args[val]}, 0) +
                coalesce(b.{b_args[val]}, 0) AS {out_args[val]}
        FROM
                (SELECT * FROM {matrix_a}
                 WHERE {a_args[val]} IS NOT NULL) AS a
            FULL OUTER JOIN
                (SELECT * FROM {matrix_b}
                 WHERE {b_args[val]} IS NOT NULL) AS b
            ON
                a.{a_args[row]} = b.{b_args[row]} AND
                a.{a_args[col]} = b.{b_args[col]}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))
    a_dim = get_dims(matrix_a, a_args)
    plpy.execute("""
        INSERT INTO {matrix_out} VALUES ({row_count}, {col_count}, NULL)
        """.format(matrix_out=matrix_out,
                   row_count=a_dim[0],
                   col_count=a_dim[1]))


def _matrix_add_dense(schema_madlib, matrix_a, a_args,
                      matrix_b, b_args, matrix_out, out_args,
                      use_temp_table=False):
    temp = '' if not use_temp_table else 'TEMP'
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            a.{a_args[row]} AS {out_args[row]},
            {schema_madlib}.array_add(
                a.{a_args[val]}::float8[],
                b.{b_args[val]}::float8[]) AS {out_args[val]}
        FROM
            {matrix_a} AS a,
            {matrix_b} AS b
        WHERE
            a.{a_args[row]} = b.{b_args[row]}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))
# ------------------------------------------------------------------------------


def matrix_block_mult(schema_madlib, matrix_a, a_args,
                      matrix_b, b_args,
                      matrix_out, out_args):

    _validate_input_table(matrix_a)
    _validate_input_table(matrix_b)
    _validate_output_table(matrix_out)

    a_args = parse_matrix_args(a_args)
    b_args = parse_matrix_args(b_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': a_args['row'],
                                                  'col': a_args['col'],
                                                  'val': a_args['val']})

    _validate_block(matrix_a, a_args)
    _validate_block(matrix_b, b_args)
    plpy.execute("""
        CREATE TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            row as {out_args[row]},
            col as {out_args[col]},
            {schema_madlib}.__matrix_mem_sum(block) AS {out_args[val]}
        FROM
        (
            SELECT
                a.{a_args[row]} AS row,
                b.{b_args[col]} AS col,
                {schema_madlib}.matrix_mem_mult(a.{a_args[val]},
                                                b.{a_args[val]}) AS block
            FROM
               {matrix_a} AS a JOIN {matrix_b} AS b
                    ON (a.{a_args[col]} = b.{b_args[row]})
        ) t1
        GROUP BY row, col
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
    """.format(**locals()))


def matrix_block_square(schema_madlib, matrix_in, in_args,
                        matrix_out, out_args):
    matrix_block_mult(schema_madlib, matrix_in, in_args, matrix_in, in_args,
                      matrix_out, out_args)


def matrix_block_trans(schema_madlib, matrix_in, in_args,
                       matrix_out, out_args,
                       use_temp_table=False):
    in_args = parse_matrix_args(in_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'col': in_args['col'],
                                                  'val': in_args['val']})
    _validate_input_table(matrix_in)
    _validate_block(matrix_in, in_args)
    _validate_output_table(matrix_out)

    temp = 'TEMP' if use_temp_table else ''
    plpy.execute("""
        CREATE {temp} TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {in_args[row]} AS {out_args[col]},
            {in_args[col]} AS {out_args[row]},
            {schema_madlib}.matrix_mem_trans({in_args[val]}) AS {out_args[val]}
        FROM
            {matrix_in}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[col]})')
    """.format(**locals()))


def _matrix_column_to_array_format(source_table, row_id, target_table, istemp=False):
    """
    Convert a dense matrix in the column format into the array format
    """
    _validate_output_table(target_table)
    row = plpy.execute("""
        SELECT nspname AS table_schema, relname AS table_name
        FROM pg_class AS c, pg_namespace AS nsp
        WHERE c.oid = '{source_table}'::regclass::oid AND
              c.relnamespace = nsp.oid
        """.format(source_table=source_table))
    _assert(len(row) > 0, "Matrix OP error: The input table doesn't exist")
    table_schema = row[0]['table_schema']
    table_name = row[0]['table_name']

    numeric_types = set(['smallint', 'integer', 'bigint',
                         'real', 'numeric', 'double precision'])
    all_columns = plpy.execute("""
        SELECT column_name, data_type
        FROM
            information_schema.columns
        WHERE
            table_schema = '{table_schema}' AND
            table_name = '{table_name}'
        ORDER BY ordinal_position
        """.format(table_schema=table_schema,
                   table_name=table_name))

    all_col_names = [column['column_name'] for column in all_columns]
    num_col_names = set(column['column_name'] for column in all_columns
                        if column['data_type'] in numeric_types)

    _assert(set(all_col_names) == num_col_names, 'Not all columns are numeric!')
    _assert(row_id in all_col_names, 'No row_id in the input table')

    all_col_names.remove(row_id)

    plpy.execute('DROP TABLE IF EXISTS ' + target_table)
    plpy.execute("""
        CREATE {temp_str} TABLE {target_table}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            {row_id}::integer as row_id, array[{val_col_names}] AS row_vec
        FROM
            {source_table}
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY (row_id)')
        """.format(target_table=target_table, row_id=row_id,
                   source_table=source_table,
                   temp_str=("", "TEMP")[istemp],
                   val_col_names=','.join(all_col_names)))


def matrix_blockize(schema_madlib, matrix_in, in_args,
                    row_dim, col_dim, matrix_out, out_args):
    _assert(row_dim > 0 and col_dim > 0, 'Matrix error: invalid block dimension')
    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)

    in_args = parse_matrix_args(in_args)
    _validate_dense(matrix_in, in_args)
    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'val': in_args['val']})

    rv = plpy.execute('SELECT count(*) AS total_row FROM ' + matrix_in)
    total_row = rv[0]['total_row']
    residual = total_row % row_dim
    border_row = (total_row / row_dim) * row_dim

    plpy.execute('DROP TABLE IF EXISTS ' + matrix_out)
    plpy.execute("""
        CREATE TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            brow_id AS {out_args[row]},
            bcol_id AS {out_args[col]},
            {schema_madlib}.__matrix_blockize_agg(
                row_id, row_vec, row_dim) AS {out_args[val]}
        FROM
        (
            SELECT
                {in_args[row]},
                {in_args[row]} / {row_dim} AS brow_id,
                CASE WHEN  {in_args[row]} < {border_row}
                    THEN {row_dim}
                    ELSE {residual}
                END AS row_dim,
                {schema_madlib}.__matrix_row_split({in_args[val]}, {col_dim}) AS row_vec,
                generate_series(0, ceil((array_upper({in_args[val]}, 1) -
                    array_lower({in_args[val]}, 1) + 1)::FLOAT8 / {col_dim})::INT4 - 1) as bcol_id
            FROM
                {matrix_in}
        ) t1
        GROUP BY brow_id, bcol_id
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
    """.format(**locals()))


def matrix_unblockize(schema_madlib, matrix_in, in_args, matrix_out, out_args):

    in_args = parse_matrix_args(in_args)
    _validate_block(matrix_in, in_args)
    _validate_input_table(matrix_in)
    _validate_output_table(matrix_out)

    out_args = parse_matrix_args(out_args,
                                 in_default_args={'row': in_args['row'],
                                                  'val': in_args['val']})
    rv = plpy.execute("""
        SELECT
            array_upper({in_args[val]}, 1) - array_lower({in_args[val]}, 1) + 1 AS row_dim,
            array_upper({in_args[val]}, 2) - array_lower({in_args[val]}, 2) + 1 AS col_dim
        FROM
            {matrix_in}
        WHERE
            {in_args[row]} = 0 and {in_args[col]} = 0
        """.format(matrix_in=matrix_in, in_args=in_args))
    row_dim = rv[0]['row_dim']
    col_dim = rv[0]['col_dim']

    rv = plpy.execute("""
        SELECT max({in_args[col]}) AS max_colid
        FROM {matrix_in}
        WHERE {in_args[row]} = 0
        """.format(matrix_in=matrix_in, in_args=in_args))
    max_colid = rv[0]['max_colid']

    rv = plpy.execute("""
        SELECT
            array_upper({in_args[val]}, 2) -
            array_lower({in_args[val]}, 2) + 1 AS col_residual
        FROM
            {matrix_in}
        WHERE
            {in_args[row]} = 0 and {in_args[col]} = 0
        """.format(matrix_in=matrix_in, in_args=in_args, max_colid=max_colid))
    col_residual = rv[0]['col_residual']

    total_col_dim = max_colid * col_dim + col_residual

    plpy.execute("""
        CREATE TABLE {matrix_out}
        m4_ifdef(`__POSTGRESQL__', `',
            `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)') AS
        SELECT
            row as {out_args[row]},
            {schema_madlib}.__matrix_unblockize_agg(
                {total_col_dim}, col * {col_dim}, row_vec) AS row_vec
        FROM
        (
            SELECT
                {in_args[row]} * {row_dim} +
                generate_series(0,
                    array_upper({in_args[val]}, 1) -
                    array_lower({in_args[val]}, 1)) AS row,
                {in_args[col]} AS col,
                {schema_madlib}.__matrix_unnest_block({in_args[val]}) AS row_vec
            FROM
                {matrix_in}
        ) t1
        GROUP BY
            row
        m4_ifdef(`__POSTGRESQL__', `',
            `DISTRIBUTED BY ({out_args[row]})')
        """.format(**locals()))


def create_temp_sparse_matrix_table_with_dims(source_table,
                                              out_table,
                                              row_id, col_id, value,
                                              row_dim, col_dim):
    """
    Make a copy of the input sparse table and add (row_dim, col_dim, NULL) to it

    This function is the specific call for sparse matrices and creates a temp
    table which is a copy of the source table. After creation, the tuples
    (row_dim, col_dim, NULL) is added to (row_id, col_id, value)

    Args:
        @param source_table Source table (sparse matrix)
        @param output_table Output table (sparse matrix)
        @param row_dim Row dimensions
        @param col_dim Column dimensions
    Returns:
        None
    """
    plpy.execute("""
                 CREATE TABLE {out_table} as
                     SELECT
                         {row_id},
                         {col_id},
                         {value}
                     FROM {source_table}
                     WHERE {value} is not NULL
                 """.format(row_id=row_id,
                            col_id=col_id,
                            value=value,
                            source_table=source_table,
                            out_table=out_table))

    plpy.execute("""INSERT INTO {out_table} VALUES
                    ({row_dim}, {col_dim}, NULL)
                 """.format(out_table=out_table, row_dim=row_dim,
                            col_dim=col_dim))
