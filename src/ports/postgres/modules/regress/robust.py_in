# coding=utf-8


"""
@file robust.py_in

@namespace robust

@brief Robust variance: Common functions
"""
import plpy
import re
from utilities.utilities import __unique_string
from utilities.utilities import extract_optimizer_param
from utilities.utilities import _assert
from utilities.utilities import py_list_to_sql_string

from utilities.validate_args import table_exists
from utilities.validate_args import table_is_empty
from utilities.validate_args import columns_exist_in_table

# use mad_vec to process arrays passed as strings in GPDB < 4.1 and PG < 9.0
from utilities.utilities import __mad_version
version_wrapper = __mad_version()
string_to_array = version_wrapper.select_vecfunc()
array_to_string = version_wrapper.select_vec_return()


def _robust_mlogregr_validate(schema_madlib, source_table, output_table,
                              dependent_varname, independent_varname,
                              ref_category, grouping_cols, verbose_mode,
                              max_iter, optimizer, tolerance, **kwargs):
    """
    Args:
        @param arg

    Returns:

    """
    if not source_table or source_table in ('null', '') or \
            not table_exists(source_table):
        plpy.error("Robust Variance error: Data table does not exist!")

    if table_is_empty(source_table):
        plpy.error("Robust Variance error: Data table is empty!")

    if not output_table or output_table.lower() in ('null', ''):
        plpy.error("Robust Variance error: Invalid output table name!")

    if table_exists(output_table):
        plpy.error("Robust Variance error: Output table already exists!")

    if not dependent_varname or dependent_varname.lower() in ('null', ''):
        plpy.error("Robust Variance error: Invalid dependent column name!")

    if not independent_varname or independent_varname.lower() in ('null', ''):
        plpy.error("Robust Variance error: Invalid independent column name!")

    if grouping_cols and grouping_cols.lower() in ('null', ''):
        plpy.error("Robust Variance error: Invalid grouping columns name!")

    if ref_category is None:
        plpy.error("Robust Variance: Reference category cannot be null!")

    if ref_category < 0:
        plpy.error("Robust Variance error: Reference category cannot be negative!")

    if max_iter <= 0:
        plpy.error("Robust Variance error: Maximum number of iterations must be positive!")

    if tolerance < 0:
        plpy.error("Robust Variance error: The tolerance cannot be negative!")

    if optimizer is None:
        plpy.error("Robust Variance error: Optimizer does not exist. Must be "
                   "'newton'/'irls'.")

    if optimizer not in ("irls", "newton"):
        plpy.error("Robust Variance error: Optimizer does not exist. "
                   "Must be either 'newton' or 'irls'. ")

    if verbose_mode is None or not isinstance(verbose_mode, bool):
        plpy.error("Robust Variance error: The verbose_mode should be of BOOLEAN type!")

# -------------------------------------------------------------------------


# Main function call for robust variance multinomial logistic regression
def robust_variance_mlogregr(
        schema_madlib, source_table,
        out_table, dependent_varname,
        independent_varname, ref_category,
        grouping_cols=None, optimizer_params=None, regr_coef=None,
        verbose_mode=False, **kwargs):
    """
    @brief A wrapper function for the robust_variance_mlogregr.

    @param source_table string, name of the input table
    @param out_table string, name of the output table to be created
    @param dependent_varname: string, Column containing the dependent variable
    @param independent_varname string, Column containing the array of independent variables
    @param ref_category int, Reference category for multinomial logistic regression
    @param grouping_cols string, Set of columns to group by.
    @param optimizer_params: string, Comma-separated string of optimizer parameters
                            Supported parameters:
                                max_iter: Maximum number of iterations (Default = 20)
                                optimzer: Optimizer to be used (newton/irls, Default = irls)
                                tolerance: Residual tolerance (Default = 0.0001)

    To include an intercept in the model, set one coordinate in the
    <tt>independentVariables</tt> array to 1.

    Returns:
        None
    """
    # Reset the message level to avoid random messages
    old_msg_level = plpy.execute("""
                                  SELECT setting
                                  FROM pg_settings
                                  WHERE name='client_min_messages'
                                  """)[0]['setting']
    if verbose_mode:
        plpy.execute('SET client_min_messages TO warning')
    else:
        plpy.execute('SET client_min_messages TO error')

    #extract optimizer parameters
    allowed_param_types = {'max_iter': int, 'max_num_iterations': int,
                           'optimizer': str,
                           'tolerance': float, 'precision': float}
    default_optimizer_values = {'max_iter': 20,
                                'optimizer': 'irls',
                                'tolerance': 0.0001}
    optimizer_param_dict = extract_optimizer_param(optimizer_params,
                                                   allowed_param_types,
                                                   default_optimizer_values)
    if not optimizer_param_dict:
        optimizer_param_dict = default_optimizer_values
    if 'precision' in optimizer_param_dict and \
            'tolerance' not in optimizer_param_dict:
        optimizer_param_dict['tolerance'] = optimizer_param_dict['precision']
    if 'max_num_iterations' in optimizer_param_dict and \
            'max_iter' not in optimizer_param_dict:
        optimizer_param_dict['max_iter'] = optimizer_param_dict['max_num_iterations']

    # Validate arguments
    _robust_mlogregr_validate(schema_madlib, source_table, out_table,
                              dependent_varname, independent_varname,
                              ref_category, grouping_cols, verbose_mode,
                              **optimizer_param_dict)

    all_arguments = {'schema_madlib': schema_madlib,
                     'source_table': source_table,
                     'output_table': out_table,
                     'dependent_varname': dependent_varname,
                     'independent_varname': independent_varname,
                     'ref_category': ref_category,
                     'grouping_cols': grouping_cols}
    all_arguments.update(optimizer_param_dict)

    if not grouping_cols:
        # Step 1: Create output table with appropriate column names
        plpy.execute("""
            CREATE TABLE {0} (
                coef          DOUBLE PRECISION[],
                std_err       DOUBLE PRECISION[],
                z_stats       DOUBLE PRECISION[],
                p_values      DOUBLE PRECISION[])
            """.format(out_table))

        # Step 2: Run the regression if the coefficients are not provided
        if not regr_coef:
            mlog_out_table = __unique_string()
            plpy.execute("""
                SELECT {schema_madlib}.mlogregr_train(
                    '{source_table}',
                    '{mlog_out_table}',
                    '{dependent_varname}',
                    '{independent_varname}',
                    {ref_category},
                    'max_iter={max_iter},
                    optimizer={optimizer},
                    tolerance={tolerance}')
                """.format(mlog_out_table=mlog_out_table, **all_arguments))

            regr_coef = string_to_array(plpy.execute("SELECT coef from {0}".
                                                     format(mlog_out_table)
                                                     )[0]['coef'])
        num_categories = int(plpy.execute("SELECT count(DISTINCT {0}) as n_cat "
                                          "FROM {1}".format(
                                              dependent_varname,
                                              source_table)
                                          )[0]['n_cat'])
        all_arguments['num_categories'] = num_categories

        # Step 3. Run Robust Variance
        robust_rst = plpy.execute("""
            SELECT ({schema_madlib}.robust_mlogregr(
                        ({dependent_varname})::INTEGER,
                        {num_categories},
                        {ref_category},
                        {independent_varname},
                        {coef})).*
            FROM {source_table}
            """.format(coef=py_list_to_sql_string(regr_coef),
                       **all_arguments))

        coef = string_to_array(robust_rst[0]["coef"])
        std_err = string_to_array(robust_rst[0]["std_err"])
        p_values = string_to_array(robust_rst[0]["p_values"])
        z_stats = string_to_array(robust_rst[0]["z_stats"])

        # Step 4: Insert into table
        insert_string = """
                    INSERT INTO {0} VALUES ({1}, {2}, {3}, {4})
                    """.format(out_table,
                               py_list_to_sql_string(coef),
                               py_list_to_sql_string(std_err),
                               py_list_to_sql_string(z_stats),
                               py_list_to_sql_string(p_values))

        # Step 5: Clean up output to make sure infinity and nan are cast properly
        insert_string = re.sub('Infinity', "'Infinity'::double precision", insert_string)
        insert_string = re.sub('inf', "'Infinity'::double precision", insert_string)
        insert_string = re.sub('Nan', "'Nan'::double precision", insert_string)
        plpy.execute(insert_string)
        # Drop the mlogregr table created in process
        plpy.execute("DROP TABLE IF EXISTS {table}".format(table=mlog_out_table))

    plpy.execute("SET client_min_messages TO %s" % old_msg_level)
# ========================================================================


def robust_variance_mlogregr_new(schema_madlib,
                                 model_table,
                                 output_table,
                                 **kwargs):
    """
    Updated function interface to extract parameters from mlogregr_train outputs

    Input to this function is the model table obtained from mlogregr_train. All
    necessary parameters are obtained from the model table.

    Args:
        @param model_table: string, Name of the table returned by mlogregr_train
        @param output_table: string, name of the output table to be created
    """
    _assert(model_table is not None and
            model_table.strip().lower() not in ('null', ''),
            "Robust Variance error: Invalid model table name")

    _assert(table_exists(model_table),
            "Robust Variance error: Model table {0} does not exist".
            format(model_table))

    _assert(table_exists(model_table + "_summary"),
            "Robust Variance error: Model Summary table {0} does not exist".
            format(model_table + "_summary"))

    _assert(output_table is not None and
            output_table.strip().lower() not in ('null', ''),
            "Robust Variance error: Invalid output table name")

    _assert(not table_exists(output_table),
            "Robust Variance error: Output table {0}"
            " already exists".format(str(output_table)))

    _assert(columns_exist_in_table(model_table,
                                   ['coef']),
            "Robust Variance error: Invalid model data table"
            " - column coef missing")

    _assert(columns_exist_in_table(model_table + '_summary',
            ['source_table', 'dependent_varname', 'independent_varname',
             'optimizer_params', 'ref_category']),
            "Robust Variance error: Invalid model summary table"
            " - required columns missing")

    # info is a dict that contains source_table, ind_var, dep_var,
    info = plpy.execute("SELECT * FROM {0}_summary".format(model_table))[0]
    coef = string_to_array(plpy.execute("SELECT coef from {0}".
                                        format(model_table))[0]['coef'])
    robust_variance_mlogregr(schema_madlib=schema_madlib, regr_coef=coef,
                             **info)
# -------------------------------------------------------------------------


def robust_variance_mlogregr_help(schema_madlib, message, **kwargs):
    """
    Help function for robust_variance_mlogregr

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Functionality: Calculate Huber-White robust statistics for multinomial logistic regression

For more details on function usage:
    SELECT {schema_madlib}.robust_variance_mlogregr('usage')
            """
    elif message in ['usage', 'help', '?']:
        help_string = """
-----------------------------------------------------------------------
                            USAGE
-----------------------------------------------------------------------
 SELECT {schema_madlib}.robust_variance_mlogregr(
    'source_table',          -- Name of data table
    'output_table',          -- Name of result table
    'dependent_variable',    -- Name of column for dependent variables
    'independent_variable',  -- Name of column for independent variables
    ref_category,            -- Reference category for the multinomial logistic regression
                             --  (Optional, DEFAULT=0)
    'grouping_cols',         -- An expression list used to group the input dataset into discrete groups.
                             --  (Optional, DEFAUT=NULL.
                             --   Not currently implemented. Any non-NULL value is ignored.)
    'optimizer_params',      -- The optimizer parameters as a comma-separated string
                             --  (Optional, DEFAULT: max_iter=20, optimizer=irls, tolerance=0.0001)
    verbose_mode             -- When TRUE, provides verbose output of the results of training.
                                   (Optional, DEFAUT=FALSE)
    );

-----------------------------------------------------------------------
                            OUTUPT
-----------------------------------------------------------------------
The output table ('output_table' above) has the following columns
    coef          DOUBLE PRECISION[], -- Coefficients of mlogit regression
    std_err       DOUBLE PRECISION[], -- Huber-White standard errors
    z_stats       DOUBLE PRECISION[], -- Z-stats of the standard errors
    p_values      DOUBLE PRECISION[], -- p-values of the standard errors
        """
    else:
        help_string = "No such option. Use {schema_madlib}.robust_variance_mlogregr()"

    return help_string.format(schema_madlib=schema_madlib)
