"""
@file margins.py_in

@brief Marginal Effects with Interactions: Common functions

@namespace marginal
"""

import plpy
from margins_common import margins_validate_model_table
import margins_logregr

from utilities.utilities import _assert
from utilities.validate_args import table_exists
from utilities.validate_args import table_is_empty
from utilities.validate_args import columns_exist_in_table
#------------------------------------------------------------------------------


def margins(schema_madlib, model_table, out_table, x_design=None,
            source_table=None, marginal_vars=None, *args, **kwargs):
    """
    Call the appropriate margins functions depending on the regression type
    found in the model table.

    Args:
        @param schema_madlib
        @param model_table
        @param out_table
        @param x_design
        @param source_table
        @param marginal_vars
        @param args
        @param kwargs

    Returns:
        None
    """
    margins_validate_model_table(model_table)
    # get the relevant regression type
    if model_table:
        model_summary_table = model_table + "_summary"
    else:
        raise ValueError("Margins error: Invalid regression model table name!")

    reg_type = plpy.execute("SELECT method from {0}".format(model_summary_table))[0]['method']
    if not reg_type:
        plpy.error("Margins error: Regression type cannot be obtained from the model table")
    elif reg_type in ("logregr", "logistic", "logistic_regression"):
        margins_logregr.margins_logregr(schema_madlib, model_table, out_table,
                                        x_design, source_table, marginal_vars,
                                        *args, **kwargs)
    else:
        plpy.error("Margins not supported for {0}".format(str(reg_type)))
#------------------------------------------------------------------------------


def margins_help(schema_madlib, message, **kwargs):
    """
    Help function for margins

    Args:
        @param schema_madlib
        @param message: string, Help message string
        @param kwargs

    Returns:
        String. Help/usage information
    """
    if not message:
        help_string = """
-----------------------------------------------------------------------
                            SUMMARY
-----------------------------------------------------------------------
Functionality: Calculate marginal effects for binomial/multinomial logistic
regression with interaction terms.
A marginal effect (ME) or partial effect measures the effect on the
conditional mean of a response (dependent variable) for a change in one of the
regressors (independent variable).

For more details on function usage:
    SELECT {schema_madlib}.margins('usage')
            """
    elif message in ['usage', 'help', '?']:
        help_string = """
-----------------------------------------------------------------------
                            USAGE
-----------------------------------------------------------------------
 SELECT {schema_madlib}.margins(
    'model_table',              -- Name of table containing regression model
    'output_table',             -- Name of result table
    'x_design',                 -- Design of the independent variables
                                --  (Optional, if not provided or NULL then independent variable list
                                         is assumed to have no interaction terms)
    'source_table',             -- Source table to apply marginal effects on
                                --  (Optional, if not provided or NULL then assume training table as the source)
    'marginal_vars'             -- Indices of variables to calculate marginal effects on
                                --  (Optional, if not provided or NULL then compute marginal effects for all basis variables)
    );

-----------------------------------------------------------------------
                            OUTUPT
-----------------------------------------------------------------------
The output table ('output_table' above) has the following columns
    variables       INTEGER[],            -- Indices of the basis variables,
                                          --   will be same as marginal vars if provided
    margins         DOUBLE PRECISION[],   -- Marginal effects
    std_err         DOUBLE PRECISION[],   -- Standard errors using delta method
    z_stats         DOUBLE PRECISION[],   -- z-stats of the standard errors
    p_values        DOUBLE PRECISION[],   -- p-values of the standard errors
        """
    else:
        help_string = "No such option. Use {schema_madlib}.margins()"

    return help_string.format(schema_madlib=schema_madlib)
# ---------------------------------------------------------------------


def create_dummy_coding(schema_madlib, origin_table, out_table,
                        indicators, distributed_by=None,
                        keep_null=False, **kwargs):
    """
    Helper function that can be used to create dummy coding for
    categorical variables.
    Args:
        @param origin_table The original data table
        @param out_table    The output table that contains the dummy
                            variable columns
        @param indicators   A string, comma separated column names for
                            for categorical variables
    """
    cols = indicators.split(',').strip()
    validate_create_dummy_coding(origin_table, out_table, cols)
    sql_list = ["create table " + out_table + " as (select *, "]
    for col in cols:
        distinct = plpy.execute("""
                SELECT {col} AS value FROM {origin_table} GROUP BY {col}
                """.format(col=col, origin_table=origin_table))
        distinct = [item['value'] for item in distinct]
        sql_list.append(', '.join("case when " + col + " = " + str(value) +
                                  " then 1 else 0 end) as " + col + "_" + str(value)
                                  for value in distinct if value is not None))
        if keep_null and None in distinct:
            sql_list.append(", (case when " + col + " is NULL then 1 else 0) as "+
                            col + "_NULL")
        sql_list.append(" from " + origin_table + ")")
        if distributed_by is not None:
            sql_list.append("distributed by" + "(" + ",".join(distributed_by) + ")")
        plpy.execute(''.join(sql_list))
    return None
# ---------------------------------------------------------------


def validate_create_dummy_coding(origin_table, out_table, cols):
    """
    Args:
        @param origin_table The original data table
        @param out_table    The output table that will contain dummy columns
        @param cols         An array of categorical column names
    """
    _assert(out_table and
            out_table.strip().lower() not in ('null', ''),
            "Creating dummy coding error: Invalid output table name!")
    _assert(not table_exists(out_table),
            "Creating dummy coding error: Output table already exists!")
    _assert(not table_exists(out_table + '_summary'),
            "Creating dummy coding error: Output summary table already exists!")

    _assert(origin_table and origin_table.strip().lower() not in ('null', ''),
            "Creating dummy coding error: Invalid data table name!")
    _assert(table_exists(origin_table),
            "Creating dummy coding error: Data table ({0}) is missing!".format(origin_table))
    _assert(not table_is_empty(origin_table),
            "Creating dummy coding error: Data table ({0}) is empty!".format(origin_table))

    _assert(columns_exist_in_table(origin_table, cols),
            "Creating dummy coding error: Invalid original table ({0})"
            " - some required columns missing".format(origin_table))
